# 引言
Linux是当今世界上最大的开源项目，也是生产环境使用的最多的操作系统。
我当然没那个本事讲清楚这个系统的所有使用方法和特性，因此这篇讲义更正式的叫法应该是“终端机使用和部分Linux命令”

我不会解释太多原理的内容，只是简要介绍使用方法。
我默认以Ubuntu系统来讲解，这个你们应该都有安装。

# 终端模拟器和shell
在图形化环境里（在linux中一般称之为xx桌面环境），以你们正在使用的这个Ubuntu的图形化环境为例，当你按下Ctrl+Alt+T的时候，会弹出一个“命令行窗口”，这个东西其实叫做“终端模拟器”，简单来说他就是在模拟早期计算机终端的交互，但是一般会提供更多的可配置项。
而在终端模拟器里装载的程序，也就是你们所看到的“命令提示符”的来源，被称为“shell”，不同的shell会有不同的功能和特性，比如在Ubuntu上默认使用的bash，如果你们认真写了操作系统课程第二次的实验，那你们应该很容易理解我在说什么。
终端模拟器给我们提供了近似终端的交互界面和视觉效果，shell为我们解析命令，让我们能够去调用执行计算机里的程序。当然背后真正在工作的其实是操作系统。
如果你发现你的命令行的行为或者功能与我的或者别人的电脑不一致，那就是终端模拟器和shell的版本和配置的区别。
# 命令
命令是我们执行程序和指定程序行为的途径。
## 基本结构
命令的基本结构如下：
```bash
<可执行文件路径> <参数列表>
```
这是最简单的命令结构。
### 路径信息补充
你们应该对路径的结构并不陌生，但你们需要知道linux中路径的表示方法。
```bash
./ 
../
```
这里两个路径，第一个是当前目录，第二个是上一级目录。 


## 运行命令
为了便于下文的解释，我们将上方的这个结构称为一个“命令”。
当你按下回车时，shell会解析这条命令，并从环境变量指定的目录中查找对应名称的可执行文件（如果你使用的是windows提供的powershell，那命令同时也会在当前目录下查找，且输入命令时不需要加.exe后缀名），并将依据执行文件创建一个新的进程，其中参数列表会传入main函数中，也就是所谓的
```c
int main(int argc, char *argv[])
```
其中argc指定的是参数的个数，argv是一个指针数组，每个元素指向一个字符串，表示命令行参数。
你可以自己写一个程序，比如：
```c
#include <stdio.h>
int main(int argc, char *argv[])
{
    for (int i = 1; i < argc; i++) {
        printf("%s ", argv[i]);
    }
    printf("\n");
    return 0;
}
```
当你编译完成这个程序，并将其放到某个目录下，你可以用命令运行它：
```bash
./myprogram arg1 arg2 arg3
```
你会看到结果：
```bash
arg1 arg2 arg3
```
这就是一个最简单的命令，它会打印出命令行参数。

我们通过终端这种形式使用计算机资源都要依靠命令，命令的语法和用法都有很多种，但基本的命令结构是固定的。之后的讲解都是命令的扩展和变体。

（环境变量会在之后的课程中讲解。）


## 常用命令（或者说程序）
一般来说，任何shell都支持以下命令：
### ls
列出当前目录下的文件和目录。
```bash
ls
```
### cd
切换目录。
```bash
cd <目录名>
```
### mkdir
创建目录。
```bash
mkdir <目录名>
```
### touch
创建文件。
```bash
touch <文件名>
```
### rm
删除文件或目录。
```bash
rm <文件或目录名>
```
### cp
复制文件或目录。
```bash
cp <源文件或目录> <目标文件或目录>
```
### mv
移动文件或目录。
```bash
mv <源文件或目录> <目标文件或目录>
```
### cat
打印文件内容。
```bash
cat <文件名>
```
### echo
打印字符串。
```bash
echo <字符串>
```
### clear
清屏。
```bash
clear
```
### exit
退出终端。
```bash
exit
```
### pwd
打印当前目录。
```bash
pwd
```
### grep
搜索文件内容。
```bash
grep <搜索字符串> <文件名>
```
### man
查看命令的帮助文档。
```bash
man <命令名>
```
这里只是在做列举，实际上大部分Linux发行版都为我们提供了大量的实用程序，为了不产生歧义，我在下文中会统一称命令中的\<可执行文件名\>部分为“程序”，上文这些不需要记忆，只是做列举，我会在文末将所有的常用程序列举出来。
（其实上述有相当多的程序是Unix标准工具）

## 高级的命令语法
事先声明，因为不同的shell对命令的解析行为是不一致的，所以下面的内容可能不适用于所有shell，但bash可以正常使用
### 注释
shell在解析命令时，井号#以及后面的同一行里的内容都会被忽略掉，这被称为注释。
```bash
# 这是一个注释
echo "Hello, world!"  # 这也是注释
```

### 重定向
#### 结构
你可以通过在命令的后方添加重定向符号，来将命令的输出重定向到其他文件（linux一切皆文件）
```bash
<命令> <重定向符号> <文件名>
```
为了便于理解，我们重新定义的基本结构，
我们现在得到了完整的命令结构：
```bash
<可执行文件路径> <参数列表> <重定向符号> <文件名>
```
这与我们的定义是一致的，因为重定向也是在指定程序的行为。
而其中，只有"可执行文件路径"是必须的，其他部分都是可选的。
#### 通用重定向符号
一般来说所有shell都支持以下重定向符号：
```bash
>  # 输出重定向符号，将命令的输出重定向到文件，如果文件不存在，则创建文件。
>> # 追加重定向符号，将命令的输出追加到文件末尾，如果文件不存在，则创建文件。
<  # 输入重定向符号，将文件的内容作为命令的输入，如果文件不存在，则会报错。
```
举例：
```bash
echo "Hello, world!" > hello.txt    # 你不会看到输出，如果你打开hello.txt，你会看到Hello, world!
wc   < hello.txt                    # 你会看到Hello, world!的行数、单词数、字符数
echo "Hello, world!" >> hello.txt   # 你不会看到输出，如果你打开hello.txt，你会看到两行Hello, world!
cat hell.txt                        # 你会看到两行Hello, world!
echo 1 > hello.txt                  # 你不会看到输出，如果你打开hello.txt，你会看到1 
```

#### （linux可用）使用文件描述符的重定向
在linux中，文件描述符是操作系统用来管理文件和进程之间通信的一种抽象概念。一般使用一个无符号整数来表示。
其中，0表示标准输入，1表示标准输出，2表示标准错误。
有些shell支持我们使用文件描述符来重定向命令的输入和输出，比如bash：
假设我们有这么一个程序：
```cpp
#include <iostream>
int main()
{
    std::cout << "Hello, world!" << std::endl;
    std::error << "Error!" << std::endl;
    return 0;
}
```
假设编译出来的程序是myprogram，我们有以下例子：
```bash
./myprogram 1> output.txt # 屏幕输出Error!，output.txt的内容是Hello, world!
./myprogram 2> error.txt   # 屏幕输出Hello, world!，error.txt的内容是Error!
```

我们也可以将文件描述符作为被重定向文件，为了表示被定向者是一个文件描述符，需要在其前方加一个&符号
```bash
./myprogram 2>1  # 将标准错误重定向到名为"1"的文件
./myprogram 2>&1 # 将标准错误重定向到标准输出
```

#### 多路重定向
重定向符号可以同时使用多个，输入重定向会按顺序将重定向的文件中的内容放入输入缓冲区（文件描述符0），输出重定向会分别向被定向文件进行输出。
```bash
./myprogram < input.txt > output.txt  # 输入input.txt的内容作为myprogram的输入，输出重定向到output.txt
./myprogram < input.txt 2> error.txt  # 输入input.txt的内容作为myprogram的输入，错误重定向到error.txt
./myprogram > 1.txt > 2.txt  # 输出重定向到1.txt，同时输出重定向到2.txt，1.txt和2.txt中都会有"Hello, world!"
```
#### 管道
管道是一种特殊的重定向，它是将一个命令的输出作为另一个命令的输入。
其基本结构如下：
```bash
<命令1> | <命令2>
```
其中，"|"符号是管道符号。
为了便于讲解，我们把多个命令的连续调用或者按照一定时间顺序的调用称为一个“任务”
举例：
```bash
ls -l | grep .txt  # 列出当前目录下所有以.txt结尾的文件的详细信息
```
你可以将管道符号理解为一种语法糖，因为上方这一行命令实际上是和下方的命令等价的：
```bash
grep .txt <(ls -l)  # 等价于上方命令，要将重定向符号后方的命令用括号括起来，且与重定向符号相连（有的shell并不支持这种语法）
```
更直观的，也可以这样：
```bash
ls -l > tem         # 列出当前目录下所有文件信息，并将输出保存到tem文件中
grep .txt < tem     # 读取tem文件的内容，并搜索以.txt结尾的文件信息
rm tem              # 删除tem文件
```
> 这里其实使用到了缓冲区的思想，我们其实是通过命令由我们维护了一块缓冲区，而管道其实是将维护缓冲区的任务交给了linux来完成。
> 随着我们对操作系统的理解的加深，你们会发现linux的很多特性都是在维护缓冲区。

管道也可以连续使用，比如：
```bash
ls -l | grep .txt | wc -l  # 列出当前目录下所有以.txt结尾的文件的详细信息，并统计文件个数
```
也可以复杂一些：
```bash
ls -l | grep .txt | awk '{print $5}' | sort -n | head -n 10  # 列出当前目录下所有以.txt结尾的文件的详细信息，并统计文件大小，并按照文件大小排序，输出前10个
```

### 后台运行
有些命令需要长时间运行，或者需要在后台运行，这时候我们可以使用&符号。
```bash
sleep 100 &  # 运行sleep命令，并将其放入后台运行
```
这个时候我们查看进程列表，就会看到一个叫做“sleep”的进程。
不过当你的shell退出时，这个进程也会退出。
还可以结合重定向的知识，
```bash
./myprogram > output.txt & # 这个时候你只需要等待程序在后台执行完毕，结果就会输出到output.txt，而你可以在前台做其他事情
./myprogram > /dev/null 2> /dev/null & # 这样做你就不会在屏幕上看到任何东西，但是程序还是依旧在后台运行
```
> 这里的/dev/null是linux中的一个特殊的文件，向这个文件中输入内容都会被丢弃，就像丢到了黑洞里一样，我会在讲到linux“一切皆文件”的时候具体解释

## 关于shell的补充说明
### shell的包含调用
shell是可以自己调用自己的，也就是说，你可以在shell中启动shell，
```bash
bash
```
这时候你就进入了一个新的shell，你可以在这个新的shell中执行命令，也可以在这个新的shell中启动新的shell。
如果你想退出当前的shell，可以使用命令：
```bash
exit
```
然后你会发现你的终端模拟器并没有关闭。
这个被调用的shell退出了。

### 环境变量
环境变量是shell中存储的键值对，它可以储存shell的配置信息、路径或者其他数据。
如果你想查看当前环境变量，可以使用命令：
```bash
env
```
如果你想设置环境变量，可以使用命令：
```bash
export <变量名>=<值>
```
如果你想查看某个特定的环境变量的值，则可以使用命令：
```bash
echo $<变量名>
```
shell在解析命令时如果检测到了$符号，则会尝试从环境变量中查找对应的值，并将其替换为真实的值。
常见的环境变量有：
```bash
$HOME  # 当前用户的主目录
$PWD   # 当前工作目录
$PATH  # shell搜索可执行文件的路径
$USER  # 当前用户的用户名
$HTTP_PROXY # http代理地址
```
> 这些值对shell调用的程序也是可见的，如果你们还记得rot的初始化过程的话，那你应该能理解这一点。


#### PATH环境变量
PATH环境变量存储了shell搜索可执行文件的路径，它是一个用冒号分隔的字符串。
当shell执行一个可执行文件时，它会在PATH环境变量中寻找可执行文件的位置。
如果你想查看PATH环境变量的值，可以使用命令：
```bash
echo $PATH
```
如果你想添加一个路径到PATH环境变量，可以使用命令：
```bash
export PATH=$PATH:<路径>
```

### bultin命令（内嵌命令）
为了命令执行的效率，shell会将一些命令的实现包含到shell本体中，从而减少调用过程带来的性能开销，这一类命令称为内嵌命令。
比如说echo命令，一般的shell都会有内部实现。
如果你复制别人的命令发现无法执行，那可以考虑一下是不是这个问题。


### 历史记录
一般来说，你可以通过按键盘上的上箭头和下箭头来查看历史命令。
但是，如果你使用的是bash，你还可以用以下命令查看历史命令：
```bash
history
```
> 这里有必要说明，历史记录并不一定是shell提供的，他有可能是终端模拟器负责记录的，也有可能是操作系统负责记录的。所以如果你在完成shell那一次的作业的时候，如果没有手动实现历史记录机制，而就出现了按上下箭头查看历史命令的情况，那很有可能就是你的终端模拟器为你提供了这个功能。


### shell的输入重定向
一般来说，shell都会有这个特性：在接收到标准输入时，它会将输入的内容作为命令来执行。如果到了文件尾，shell会停止执行。你可以尝试一下向shell中输入Ctrl+D，看看会发生什么。
因此我们可以提前写好一个命令放到文件里。
假设我们有这个文件a.txt：
```bash
echo "Hello, world!"
```
我们可以用以下命令运行这个文件：
```bash
bash < a.txt # 你会看到Hello, world!
```
#### source命令
用上一个命令来执行的话，我们会启动一个新的bash进程，如果文件中的命令是改动环境变量，那很显然子shell是和父shell隔离的，这个时候我们可以使用source命令来执行这个文件：
```bash
source a.txt
```
这样a.txt中的命令就会在当前shell中执行了。
## 批处理文件和shell脚本
当我们知道了上一个shell的特性（指shell的输入重定向），我们就可以开始学习批处理文件和shell脚本了。
当你熟悉了命令的使用，你会发现某一些任务需要执行多条命令，或者需要重复执行相同的命令，这时候你就需要用到批处理文件和shell脚本。
在此之前，我想先介绍一下什么是批处理文件和shell脚本。
批处理文件和shell脚本都是文本文件，其本质就是一系列的任务，可以被shell解析执行。
区别主要在语法和特性上，批处理文件是windows的叫法（来自dos时期的历史遗留问题），而shell脚本是linux的叫法。
我们在此只讲解shell脚本的语法和特性。

但二者的本质都是按顺序执行的任务序列。

### 脚本文件的结构
从外观上看，脚本文件一般是以.sh作为后缀名的。
> 你可能还看到过.bash，.zsh，.fish等后缀名，这些也是脚本文件，并且指定了shell的版本，实际上，这些都是人为的规定，通过脚本的后缀名来标注使用什么shell来运行，而.sh就表示这是一个通用脚本。实际上你的shell并不在意脚本文件的后缀名，它只会按照文件内容来执行。
脚本文件的结构一般是这样的：
```bash
<任务1>
<任务2>
...
<任务n>
```
脚本文件中的注释同样也以#开头。
### 脚本文件的执行
