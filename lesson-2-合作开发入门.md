# 引言
一个人的力量是有限的，而以生产（而非学习）为目的任务是有截止日期的，哪怕再强大的程序员也不可能只靠自己就能在指定期限内完成项目。因此我们必须依靠团队合作，结合多个人的劳动来完成任务。
当人与人之间的合作是异步地对同一客体进行劳动时，在我看来，有两个核心的要点——“共识”和“隔离”。
## 共识
> "In collaborative arts... or virtually all arts, there\`s usually one voice ultimately.The person who is that driving force has to do one very important thing, and that is create the strategies with which everybody else can work. "

你也可以将它称之为规则、协议等，共识就是劳动中的所有主体为达成同一最终目的而创造的，所有人都知晓信息，所有人都遵守的规范。在合作开发中，它可以体现为编码规范，项目结构等。我们按照共识行事是为了所有人的劳动都能够对项目起到推进作用，且保证产出的劳动成果的一致性。那对于写代码来说，就是你不能随意地按照自己的风格去编写代码，而应该遵循团队所制定的编码规范。比如，代码的缩进风格、变量命名规则、函数的长度限制、注释的格式等。这些看似琐碎的细节，实际上是团队协作中不可或缺的部分。如果每个人都按照自己的方式去写代码，那么最终的代码库就会变得混乱不堪，难以维护和理解。当新的成员加入团队或者需要对代码进行后续的修改和扩展时，就会花费大量的时间去适应不同的代码风格，甚至可能会引入新的错误。
## 隔离
与共识不同，隔离指的是劳动中所有主体劳动成果之间的独立性和可见性。我们应当尽可能保证自己的劳动不会影响其他人已有的劳动成果，且对于每一个劳动者，我们不去关注其劳动过程和劳动成果的具体实现细节，即我们预设每个人做出的成果都是与其描述的是一致的。那对于我们合作开发来说，它可以体现在模块化的开发，以及接口的暴露上。这样，不同的开发者可以独立地开发不同的模块，而不用担心会影响到其他模块的正常运行。当一个模块出现问题时，也可以很容易地定位和修复，而不会导致整个项目的崩溃。而接口的设计也可以让我们可以只考虑如何使用功能，而不用在意如何实现功能。抽象层次就是人类在计算机领域最伟大的发明。

# 需求
我们知道，市面上的产品大多都是面向需求开发的，了解了上文后，我们还知道，其实使用现有的面向合作开发的产品实际上也是在遵循这项产品的共识和隔离属性，使用它们的目的是提高我们合作劳动的效率，如果不能实际地提高效率，那学习它们就没有意义。

因此，我们就需要对我们合作开发的需求进行分析，以便确认我们为什么需要它们，以及我们应该挑选哪些产品。


### 合作编码
#### 进度（修改）同步
那首先，我们知道，编译程序或者是解释程序，是需要所有源文件或脚本文件都存放在特定目录下，或者通过参数传入编译器、解释器或者链接器的。这些工作绝大部分现代IDE都为我们完成了，对于大部分项目来说，我们可以只考虑源文件的编写和项目目录结构的组织。
但这里就会遇到问题，如果两个或多个人同时编辑了某个源文件怎么办？那最简单的解决方法就是我们规定每个源文件都只能由同一个人负责，但这无疑是即傻瓜式又不负责任的做法，显而易见的低效，但也并非没有优点：只要项目成员不中途跳车或不负责任，那项目的维护难度就非常低（当然只是相对来说，自己的代码自己看不懂也很正常）。
那我们觉得不行啊，那要不就对每个文件打一个标记，当有人正在修改的时候就启用标记，当这个人的修改完成后就释放这个标记。这好像是解决了不能多个人修改同一个源文件的问题，但它是串行的，不够异步，这就有可能造成“线程饥饿”的问题，如果多个人都对同一个源文件有修改的需求，那可不就都在等待这个正在占用的人了吗？效率还是不够高。
那我们还可以专门设定一个人，由他来接受每个人对于同一个源文件的所有修改，并且由他结合所有的修改来设定最终的源文件，如果修改有冲突了，他还可以去找那些修改有冲突的程序员，然后商定保留哪部分修改。效果显而易见的好，成本显而易见的高——要多一个人的工资呢。那我们是不是就可以退而求其次，看看有没有软件能够替我们完成这个合并修改的工作呢？有的兄弟有的，在此先按下不表。
当然现代很多工具都已经能做到实时的同步修改了，但这一类服务的价格可能比上一种方案的那个人的工资都高。
我们以上也只是分析了合作完成这件事的需要，现实中还会涉及到计算每个人对项目的贡献量，错误代码的追责等，因此改动的简介、作者和时间信息也需要被记录下来。
#### 代码风格统一
为了我们代码的一致性、可读性和可维护性，我们需要遵循一定的编码规范，比如统一的缩进风格、变量命名规则、函数的长度限制、注释的格式等。但人是自由的，每个人的编码风格可能大相径庭，因此我们需要有一个工具来帮助我们自动化地对代码进行格式化，又或者检测代码是否符合规范。
（这个问题我不会单独介绍工具的使用方法，而是会介绍一些规范的意思）
### 版本控制
我们写代码，尤其是完成复杂的项目时，往往都不是一蹴而就的，而是经历了多次的开发迭代，可能是分模块开发，可能是按功能开发，或者为不同的客户服务而需要不同的功能集合，又或是某个功能使用不同特性的实现，又或者是在开发过程中又有了新想法，或者是项目的需求发生了变化，或者是某些改动需要舍弃并回到之前的版本，亦或是只是需要记录开发过程。
我们可以将特定的功能集合和特性集合视为一个版本，我们需要一个版本控制系统来记录每个版本的变更，以便于后续的查阅和回滚，又或者是不同版本之间功能集合和特性集合的合并和对比。
有趣的是，如果我们将合作编码中每一次的修改都视为一个版本，那么我们就可以借助版本管理工具来完成我们以上两个需求。
### 项目管理和任务分发
对于项目的管理者来说，他需要一个途径获取项目目前的进展、状态和问题，以及任务的向下分发，以保证项目对于管理者的实时性，对于开源项目来说可能任务分发没有那么重要，但对于固定团队的项目来说，任务分发就显得尤为重要，这关系到每个开发者的能力能否得到有效的发挥，以及项目的进展如何被管理者看到。
并且对于企业来说，也需要知道项目中每个成员对于该项目的贡献程度，以及记录任务的完成情况，以便于管理者对项目的整体进展和各个成员的工作情况进行评估。
对于开发者来说，我想你们在之前的工作中应该也感觉出来了，很多时候会不知道自己应该做什么，或者有了新的成果却无从汇报。
结合以上的分析，我们需要有那么一个工具，帮助我们完成项目管理和任务分发，并且能够记录每个人的贡献量，错误追责等，以便于管理者对项目的整体进展和各个成员的工作情况进行评估。
那对于我们这个项目来说，我们没有那么多复杂的需求，但是任务分发和进展的记录还是很重要的。
（那接下来也会有我来对你们进行任务的分发，你们也要及时响应才行。）
### 文档协作
写文档是开发中不得不品鉴的一环，对于一个产品来说，你需要事无巨细的把功能描述出来，对于一个代码库来说，你需要详细的记录每个模块的功能和实现，以及类型和接口的定义。并且如果有多个开发者参与开发，且可能会修改或使用同一部分代码，那么对这些代码的说明文档也是必须的。
而对于最后需要交付的文档，很多时候更像是在一起编辑同一个源文件，且大部分情况下，这个修改是同时进行的，因此能够实时看到其他人的修改的文档协作就显得尤为重要。
### 即时通讯
即时通讯我就不单独说了，这里只是列出来，提醒你们有问题或者有进度一定要及时和我说。

# 工具

那我接下来就会关于版本控制、代码检查、项目管理、文档协作来介绍一些我们接下来完成项目的过程中需要使用的工具。

## 版本控制
版本控制会有不同的方案，整体上可以分为集中式和分布式两种，集中式版本控制就是有一个中心服务器存储所有版本，由中心服务器完成所有版本控制的工作，而分布式版本控制则是每个开发者都有一份完整的版本库，版本控制工作都由各自的客户端完成，只是会在中心服务器上进行同步。
在此我只介绍Git，我们也将使用Git来完成我们的项目的版本控制。
### Git
Git是一个开源的分布式版本控制系统，由Linux之父Linus Torvalds开发，是目前最流行的版本控制系统。
Git本体提供了很多强大的命令行工具，而通过上次我讲的脚本的编写，我们也可以实现一些更加高级的功能，我在此只讲解Git的基本工作方式和使用方法，以及我会带你们过一遍Git的基本命令。
#### 基本工作方式
Git做的所有事情就是简单概括就是维护一个仓库（Repository）——一个保存项目历史记录的地方，也就是.git目录。
由Git进行管理的目录分为三个部分：工作区、暂存区和本地仓库。
- 工作区：就是你在电脑里能看到的目录，通过命令将文件的修改情况添加到暂存区。
- 暂存区：英文叫stage，临时保存修改文件用的，通过命令将暂存区的记录提交到本地仓库。
- 本地仓库：就是.git目录，这里边保存着所有的版本信息，包括提交记录、版本快照等。
文件在工作区的状态有三种：已修改（modified）、已暂存（staged）和未跟踪（untracked）。
- 已修改：表示文件已在工作区被修改，但还没有被暂存。
- 已暂存：表示文件已在暂存区，等待提交到本地仓库。
- 未跟踪：表示文件在工作区中，但并没有被纳入版本控制。
Git会检测被追踪文件的状态，并和本地仓库中的文件进行比较，如果文件不一样，Git会将文件状态标记为已修改。
而对于我们使用者来说，Git如何组织这些文件，以及如何管理这些文件，并不重要，重要的是Git暴露给我们的拓扑结构，以及Git提供的命令行工具。
分支（Branch）是 Git 的一个核心特性，它允许开发者在同一仓库中并行开发不同的功能或修复，而互不干扰。
我光靠语言描述可能比较抽象，你们看一下这个图就懂了：



我们使用git记录一个版本的流程大概是这样的：
1. 对目录启用Git进行版本管理。
    在该步骤中，使用的是
    ```bash
    git init
    ```
    这个命令，将当前目录变成一个Git仓库。
2. 在工作区中修改文件。
3. 将修改的文件添加到暂存区。
    在该步骤中，使用的是
    ```bash
    git add <文件路径>
    ```
    这个命令，将文件添加到暂存区。
4. 将暂存区的记录提交到本地仓库。
    在该步骤中，使用的是
    
    ```bash
    git commit -m "提交说明"
    ```
    这个命令，将暂存区的记录提交到本地仓库，并附上提交说明。
5. 将本地仓库的记录推送到远程仓库。
    在该步骤中，使用的是
    
    ```bash
    git push <远程仓库名> <分支名>
    ```
    这个命令，将本地仓库的记录推送到远程仓库，并指定推送的分支。
6. 从远程仓库拉取最新版本。
    在该步骤中，使用的是
        
    ```bash
    git pull <远程仓库名> <分支名>
    ```
    这个命令，从远程仓库拉取最新版本，并合并到本地仓库的指定分支。

#### 提交
 **提交（commit）** 在git中是仓库状态的一个快照，我们不需要深究它的实现细节，只需要知道，它记录了当前仓库中每个被追踪文件的状态，并且允许我们在不同的提交之间互相切换，并且它足够轻量化，我们可以做到快速的提交切换。提交时，默认会将上一个提交作为当前提交的父提交。你可以将提交视为一个节点，那不同的提交就可以构成一个图，而我们每次进行修改时，一定时基于某个提交的，因此我们整个图中所有节点之间都一定是具有一条路径的，相应的，我们就可以在任意的提交记录之间互相切换（尽管这个类比并不贴切）
 当你执行
```bash
git commit
```
之后，仓库中就实际地添加了一份快照（提交记录），如果你想查看已有的提交记录，只需要
```bash
git log
```
即可，而如果你想要回到某个提交，就需要使用
```bash
git checkout <分支描述符>
# 或者
git reset <分支描述符>
```
命令。这里的分支描述符可以是你在查看git log的时候看到的那个字符串（SHA-1哈希值），同时也可以是一些其他的东西，暂且不提。
##### git checkout
这个简单的checkout命令
```bash
git checkout
```
它实际上承载了多个功能。
1. 首先它可以用于切换分支，只需要
```bash
git checkout <分支名>
```
2. 其次它可以恢复已经更改了的文件或者文件夹
```bash
git checkout <文件路径/文件夹路径>
```
> 实际上这个功能已经在新版本的git中被独立成了另一个单独的命令git restore
> > git restore <文件路径/文件夹路径>
3. 它还可以用来更改提交记录，只需要使用
```bash
git checkout <分支描述符>
```

#### 分支
**分支（branch）** 可以说是git最具特色的特性。分支的实现非常的轻量化，它实际上只是指向一个提交，仅此而已，建立多个分支也并不会带来无法接受的存储开销，而它的功能又十分强大，因此你多多使用这个特性，它会为我们的合作开发带来很多便利。当你建立一个分支时，你可以理解为，你想要基于当前的这个提交和它所有的父提交来进行接下来的工作。
一般来说，我们在建立仓库的时候，都会创建一个**main**分支或者**master**分支，在大多数项目中，这个分支往往都意味着主干，即我们所有的分支都会是在这个分支的基础上建立的。
在git中，我们可以通过以下命令查看已有的分支
```bash
git branch    # 查看本地仓库中的分支
git branch -r # 查看远程仓库中的分支
git branch -a # 查看所有的分支
```

git建立分支非常简单，只需要
```bash
git branch <分支名>
```
git会为当前分支标注星号(\*)，而切换分支也很简单。
但是需要注意的是，在一些古早的git教程中，因为git当时功能的不完善，切换分支使用的是
```bash
git checkout <分支名>
```
而因为这个功能实际上承载了多个互相独立的小功能，在新版本的git中，切换分支一般推荐使用
```bash
git switch <分支名>
```
这个命令。
> 二者是有一些区别在的，如果当前有修改，switch命令需要你先提交修改或者撤销修改，而checkout会舍弃已有的修改。并且checkout还有许多其他功能。实际上可以看出，git的开发者们已经对git的特性进行了独立化的处理，这使得命令变得更加直观，而不混乱。

而我们在上文中也提到了，分支的目的是在独立的基础上实现合并。在git中，合并两个分支其实是建立了一份特殊的提交。你可以通过以下命令来进行合并
```bash
git merge <分支名>
```

写到这里我发现我仅通过文字来讲解是非常不直观的，效果很差，因此git的内容就讲到这里，后续请到[Learn Git Branching](https://learngitbranching.js.org/?locale=zh_CN)这个网址用更直观的方式来学习。

那我接下来会展示git在本地的使用方法。

当然其实我们三个实际会使用到的git的功能并不会复杂，但是学习一些进阶的东西对你们之后工作会有很大帮助。
## 代码托管
在前文中我们提出的很多种同步大家工作进度的方案，无一例外，我们都需要有一台服务器来处理我们的更改，并且让我们可以通过和这台服务器通讯来同步大家的更改。这样的平台就叫做代码托管平台。典型的公开的代码托管平台有gitee、github等，我们也可以通过gitlab来自行部署。

代码托管平台就是为我们提供了这样一个git远程仓库的服务。其中github最为著名，大部分开源项目都会在github上进行发布，我们下一款要使用的任务同步软件worklenz([Worklenz/worklenz: All in one project management tool for efficient teams](https://github.com/Worklenz/worklenz))也可以在GitHub上获取到。

那对于github中我们可能会用到的功能，我全部使用实际操作的方式来演示。并且在这个过程中我会结合git的命令。

## 项目管理
市场上有大量的项目任务管理的解决方案，它们各自有各自的优点，但无一例外的缺点就是：它们都要钱。
因此我选择使用一个开源的项目进度管理软件：worklenz
接下来我也会以实操的方式向你们演示使用方法。
如果你们有更好的免费的类似的软件，也可以向我推荐。

## 代码风格统一
这一条更正规的叫法其实是编码规范。
我们首先思考一下，对于大部分编程语言，我们的代码里最常用的东西是什么？
你可能想的是变量或者函数，但实际上是符号。
如果你们还记得计算机组成的知识，那应该就知道，我们写的代码最终是要被翻译成机器码的。如果你写汇编，那其实一条条的机器码都是对应的汇编代码。但实际上我们知道，不论是变量还是函数还是别的什么东西，它在内存里都是一致的，对吧，都是机器码而已。机器码除了值的区别，那就只是地址区别。高级编程语言为我们提供了一层抽象，它给我们规定了语法，变量要怎么写，函数要怎么写这样的。那我们编程，不论这个地址存放的变量是什么含义，不论这个地址放的函数是什么作用，我们本质上在做的就是对特定地址范围的机器码人为给予定义（值），这个说法能理解吗。
那对于我们的编译器来说，它怎么给我们规定语法来区分这些不同的定义呢？他让我们变量前要有类型标识符，他让我们函数要有返回类型，参数列表。发现了吗，我们实际上都是在用固定的符号格式来代表某一种含义。
那其实我们确定编码规范的目的之一就是让我们在表示不同含义的时候有对应的符号格式。
变量和函数是不是都有名称？那我们是不是就可以使用某些规范来限制二者的命名格式，以此来保证二者之间的区分度？比如我们变量要求都是用小写字母和下划线，函数都让首字母大写，常量都使用全大写。那由此就引申出了各种命名法。
>在编程中，常见的变量命名法主要有以下几种，每种都有其适用场景和风格偏好：
---

### 1. **驼峰命名法（Camel Case）**
- **小驼峰（lowerCamelCase）**：首字母小写，后续单词首字母大写。  
  **示例**：`userName`, `totalPrice`  
  **用途**：变量、函数名（JavaScript、Java、C#等）。

- **大驼峰（PascalCase）**：每个单词首字母大写。  
  **示例**：`UserName`, `DataBaseConnection`  
  **用途**：类名（Java、C#）、构造函数（JavaScript）。

---

### 2. **蛇形命名法（Snake Case）**
- **小写蛇形（snake_case）**：全小写，单词间用下划线 `_` 分隔。  
  **示例**：`user_name`, `max_length`  
  **用途**：Python变量、C语言函数、Linux系统配置（如`config_file`）。

- **大写蛇形（SCREAMING_SNAKE_CASE）**：全大写，下划线分隔。  
  **示例**：`MAX_RETRY_COUNT`, `API_KEY`  
  **用途**：全局常量（如C/C++的宏定义、Java的`static final`变量）。

---

### 3. **短横线命名法（Kebab Case）**
- **形式**：全小写，单词间用短横线 `-` 分隔。  
  **示例**：`user-name`, `background-color`  
  **用途**：URL路径（如`/user-profile`）、CSS类名（如`.main-header`）、HTML属性（如`data-value`）。  
  **注意**：多数编程语言中短横线会被解析为减号，因此不用于变量名。

---

### 4. **匈牙利命名法（Hungarian Notation）**
- **形式**：变量名前加小写字母前缀表示类型或用途。  
  **示例**：`strName`（字符串）、`iCount`（整型）、`btnSubmit`（按钮对象）。  
  **用途**：早期Windows编程（如C++的Win32 API）、部分脚本语言。  
  **现状**：现代语言（如Java、C#）因类型系统完善已较少使用。

---

### 5. **帕斯卡命名法（PascalCase）**
- 与大驼峰相同，但通常特指类名或命名空间。  
  **示例**：`FileManager`, `HttpClient`  
  **用途**：C#的类/方法名、Delphi语言。

---

### 6. **其他变体**
- **Upper Camel Case**：同PascalCase，强调首字母大写。  
- **lower_case_with_underscores**：同snake_case的别称。  
- **Train-Case**：首字母大写的Kebab-Case（如`User-Name`），极少使用。

---

### **语言与场景对照表**
| 语言/场景       | 推荐命名法                     | 示例                  |
|------------------|-------------------------------|-----------------------|
| **Python**       | snake_case（变量/函数）        | `user_name`, `def get_data():` |
| **Java**         | lowerCamelCase（变量/方法）    | `userName`, `calculateTotal()` |
| **C#**           | PascalCase（类名）             | `class UserManager {}` |
| **JavaScript**   | lowerCamelCase（变量/函数）    | `isLoggedIn`, `fetchData()` |
| **CSS**          | kebab-case（类名）             | `.main-container {}` |
| **常量（通用）** | SCREAMING_SNAKE_CASE          | `MAX_BUFFER_SIZE`     |

---

### **总结**
- **驼峰**和**蛇形**是最主流的两种，根据语言和团队规范选择。  
- **Kebab-case**仅限特定场景（如URL或CSS）。  
- **匈牙利命名法**已逐渐淘汰，除非维护旧代码。  
- **一致性**比具体风格更重要，建议遵循项目或语言的官方规范（如PEP 8 for Python）。


并且，代码中还会有注释，我们是不是也应该规定一套注释的格式，以此来保证我们之间能够以固定的方式传递代码相关的信息？
实际上企业中的编码规范除了以上内容，还会有比如循环嵌套限制、递归限制、全局变量使用限制等等要求，它们除了对可读性和可维护性有要求，还对效率和可拓展性有要求，不过对于我们三个人合作来说，且我们这个开发过程本身设计大量学习的内容，我们就没有这些要求了。

# 练习题目
1. 请完成附录中网页里的“主要”部分的“基础篇”、“高级篇”，“远程”部分的所有关卡，并截图，你可以从右下角的“levels”里切换关卡。（有这些知识就可以合作编码了，如果你想更深入的了解git可以完成其他关卡）
2. 登录GitHub，完成SSH key的配置，将该[链接中]([zhitian111/handout-for-wateros](https://github.com/zhitian111/handout-for-wateros))的仓库fork到你的仓库里，建立一个新的分支，随意做出任何修改，push到你的仓库里，唯一要求是你的commit信息和分支名需要和你做的修改有关系。
3. 阅读我们GitHub仓库里的README.md文件，查看其中的编码规范一栏，保证自己理解其中每一项的意思，不明白就来问我。
4. 接受我想你们QQ邮箱发送的团队邀请，登入worklenz。完成我布置的作业，以附件的形式在worklenz中提交。

# 附录
[Learn Git Branching](https://learngitbranching.js.org/?locale=zh_CN)