# 引言
Linux是当今世界上最大的开源项目，也是生产环境使用的最多的操作系统。
我当然没那个本事讲清楚这个系统的所有使用方法和特性，因此这篇讲义更正式的叫法应该是“终端机使用和部分Linux命令”

我不会解释太多原理的内容，只是简要介绍使用方法。
我默认以Ubuntu系统来讲解，这个你们应该都有安装。

# 终端模拟器和shell
在图形化环境里（在linux中一般称之为xx桌面环境），以你们正在使用的这个Ubuntu的图形化环境为例，当你按下Ctrl+Alt+T的时候，会弹出一个“命令行窗口”，这个东西其实叫做“终端模拟器”，简单来说他就是在模拟早期计算机终端的交互，但是一般会提供更多的可配置项。
而在终端模拟器里装载的程序，也就是你们所看到的“命令提示符”的来源，被称为“shell”，不同的shell会有不同的功能和特性，比如在Ubuntu上默认使用的bash，如果你们认真写了操作系统课程第二次的实验，那你们应该很容易理解我在说什么。
终端模拟器给我们提供了近似终端的交互界面和视觉效果，shell为我们解析命令，让我们能够去调用执行计算机里的程序。当然背后真正在工作的其实是操作系统。
如果你发现你的命令行的行为或者功能与我的或者别人的电脑不一致，那就是终端模拟器和shell的版本和配置的区别。
# 命令
命令是我们执行程序和指定程序行为的途径。
## 基本结构
命令的基本结构如下：
```bash
<可执行文件路径> <参数列表>
```

### 路径信息补充
你们应该对路径的结构并不陌生，但你们需要知道linux中路径的表示方法。
```bash
./ 
../
```
这里两个路径，第一个是当前目录，第二个是上一级目录。 


## 运行命令
为了便于下文的解释，我们将上方的这个结构称为一个“命令”。
当你按下回车时，shell会解析这条命令，并从环境变量指定的目录中查找对应名称的可执行文件（如果你使用的是windows提供的powershell，那命令同时也会在当前目录下查找，且输入命令时不需要加.exe后缀名），并将依据执行文件创建一个新的进程，其中参数列表会传入main函数中，也就是所谓的
```c
int main(int argc, char *argv[])
```
其中argc指定的是参数的个数，argv是一个指针数组，每个元素指向一个字符串，表示命令行参数。
你可以自己写一个程序，比如：
```c
#include <stdio.h>
int main(int argc, char *argv[])
{
    for (int i = 1; i < argc; i++) {
        printf("%s ", argv[i]);
    }
    printf("\n");
    return 0;
}
```
当你编译完成这个程序，并将其放到某个目录下，你可以用命令运行它：
```bash
./myprogram arg1 arg2 arg3
```
你会看到结果：
```bash
arg1 arg2 arg3
```
这就是一个最简单的命令，它会打印出命令行参数。

我们通过终端这种形式使用计算机资源都要依靠命令，命令的语法和用法都有很多种，但基本的命令结构是固定的。之后的讲解都是命令的扩展和变体。

（环境变量会在之后的课程中讲解。）


## 常用命令（或者说程序）
一般来说，任何shell都支持以下命令：
### ls
列出当前目录下的文件和目录。
```bash
ls
```
### cd
切换目录。
```bash
cd <目录名>
```
### mkdir
创建目录。
```bash
mkdir <目录名>
```
### touch
创建文件。
```bash
touch <文件名>
```
### rm
删除文件或目录。
```bash
rm <文件或目录名>
```
### cp
复制文件或目录。
```bash
cp <源文件或目录> <目标文件或目录>
```
### mv
移动文件或目录。
```bash
mv <源文件或目录> <目标文件或目录>
```
### cat
打印文件内容。
```bash
cat <文件名>
```
### echo
打印字符串。
```bash
echo <字符串>
```
### clear
清屏。
```bash
clear
```
### exit
退出终端。
```bash
exit
```
### pwd
打印当前目录。
```bash
pwd
```
### grep
搜索文件内容。
```bash
grep <搜索字符串> <文件名>
```
### man
查看命令的帮助文档。
```bash
man <命令名>
```
这里只是在做列举，实际上大部分Linux发行版都为我们提供了大量的实用程序，为了不产生歧义，我在下文中会统一称命令中的\<可执行文件名\>部分为“程序”，上文这些不需要记忆，只是做列举，我会在文末将所有的常用程序列举出来。
（其实上述有相当多的程序是Unix标准工具）

## 高级的命令语法
事先声明，因为不同的shell对命令的解析行为是不一致的，所以下面的内容可能不适用于所有shell，但bash可以正常使用
### 注释
shell在解析命令时，井号#以及后面的同一行里的内容都会被忽略掉，这被称为注释。
```bash
# 这是一个注释
echo "Hello, world!"  # 这也是注释
```

### 重定向
#### 结构
你可以通过在命令的后方添加重定向符号，来将命令的输出重定向到其他文件（linux一切皆文件）
```bash
<命令> <重定向符号> <文件名>
```
#### 通用重定向符号
一般来说所有shell都支持以下重定向符号：
```bash
>  # 输出重定向符号，将命令的输出重定向到文件，如果文件不存在，则创建文件。
>> # 追加重定向符号，将命令的输出追加到文件末尾，如果文件不存在，则创建文件。
<  # 输入重定向符号，将文件的内容作为命令的输入，如果文件不存在，则会报错。
```
举例：
```bash
echo "Hello, world!" > hello.txt    # 你不会看到输出，如果你打开hello.txt，你会看到Hello, world!
wc   < hello.txt                    # 你会看到Hello, world!的行数、单词数、字符数
echo "Hello, world!" >> hello.txt   # 你不会看到输出，如果你打开hello.txt，你会看到两行Hello, world!
cat hell.txt                        # 你会看到两行Hello, world!
echo 1 > hello.txt                  # 你不会看到输出，如果你打开hello.txt，你会看到1 
```
#### （linux可用）使用文件描述符的重定向
在linux中，文件描述符是操作系统用来管理文件和进程之间通信的一种抽象概念。一般使用一个无符号整数来表示。
其中，0表示标准输入，1表示标准输出，2表示标准错误。
有些shell支持我们使用文件描述符来重定向命令的输入和输出，比如bash：
假设我们有这么一个程序：
```cpp
#include <iostream>
int main()
{
    std::cout << "Hello, world!" << std::endl;
    std::error << "Error!" << std::endl;
    return 0;
}
```
假设编译出来的程序是myprogram，我们有以下例子：
```bash
./myprogram 1> output.txt # 屏幕输出Error!，output.txt的内容是Hello, world!
./myprogram 2> error.txt   # 屏幕输出Hello, world!，error.txt的内容是Error!
```


## 关于shell的补充说明
### shell的包含调用
shell是可以自己调用自己的，也就是说，你可以在shell中启动shell，
```bash
bash
```
这时候你就进入了一个新的shell，你可以在这个新的shell中执行命令，也可以在这个新的shell中启动新的shell。
如果你想退出当前的shell，可以使用命令：
```bash
exit
```
然后你会发现你的终端模拟器并没有关闭。
这个被调用的shell退出了。

### 环境变量

### bultin命令（内嵌命令）

## 批处理文件和shell脚本
当你熟悉了命令的使用，你会发现某一些任务需要执行多条命令，或者需要重复执行相同的命令，这时候你就需要用到批处理文件和shell脚本。
在此之前，我想先介绍一下什么是批处理文件和shell脚本。
批处理文件和shell脚本都是文本文件，其本质就是一系列的命令，
