# 引言
一个人的力量是有限的，而以生产（而非学习）为目的任务是有截止日期的，哪怕再强大的程序员也不可能只靠自己就能在指定期限内完成项目。因此我们必须依靠团队合作，结合多个人的劳动来完成任务。
当人与人之间的合作是异步地对同一客体进行劳动时，在我看来，有两个核心的要点——“共识”和“隔离”。
## 共识
你也可以将它称之为规则、协议等，共识就是劳动中的所有主体为达成同一最终目的而创造的，所有人都知晓信息，所有人都遵守的规范。在合作开发中，它可以体现为编码规范，项目结构等。我们按照共识行事是为了所有人的劳动都能够对项目起到推进作用，且保证产出的劳动成果的一致性。那对于写代码来说，就是你不能随意地按照自己的风格去编写代码，而应该遵循团队所制定的编码规范。比如，代码的缩进风格、变量命名规则、函数的长度限制、注释的格式等。这些看似琐碎的细节，实际上是团队协作中不可或缺的部分。如果每个人都按照自己的方式去写代码，那么最终的代码库就会变得混乱不堪，难以维护和理解。当新的成员加入团队或者需要对代码进行后续的修改和扩展时，就会花费大量的时间去适应不同的代码风格，甚至可能会引入新的错误。
## 隔离
与共识不同，隔离指的是劳动中所有主体劳动成果之间的独立性和可见性。我们应当尽可能保证自己的劳动不会影响其他人已有的劳动成果，且对于每一个劳动者，我们不去关注其劳动过程和劳动成果的具体实现细节，即我们预设每个人做出的成果都是与其描述的是一致的。那对于我们合作开发来说，它可以体现在模块化的开发，以及接口的暴露上。这样，不同的开发者可以独立地开发不同的模块，而不用担心会影响到其他模块的正常运行。当一个模块出现问题时，也可以很容易地定位和修复，而不会导致整个项目的崩溃。而接口的设计也可以让我们可以只考虑如何使用功能，而不用在意如何实现功能。抽象层次就是人类在计算机领域最伟大的发明。

# 需求
我们知道，市面上的产品大多都是面向需求开发的，了解了上文后，我们还知道，其实使用现有的面向合作开发的产品实际上也是在遵循这项产品的共识和隔离属性，使用它们的目的是提高我们合作劳动的效率，如果不能实际地提高效率，那学习它们就没有意义。

因此，我们就需要对我们合作开发的需求进行分析，以便确认我们为什么需要它们，以及我们应该挑选哪些产品。


### 合作编码
#### 进度（修改）同步
那首先，我们知道，编译程序或者是解释程序，是需要所有源文件或脚本文件都存放在特定目录下，或者通过参数传入编译器、解释器或者链接器的。这些工作绝大部分现代IDE都为我们完成了，对于大部分项目来说，我们可以只考虑源文件的编写和项目目录结构的组织。
但这里就会遇到问题，如果两个或多个人同时编辑了某个源文件怎么办？那最简单的解决方法就是我们规定每个源文件都只能由同一个人负责，但这无疑是即傻瓜式又不负责任的做法，显而易见的低效，但也并非没有优点：只要项目成员不中途跳车或不负责任，那项目的维护难度就非常低（当然只是相对来说，自己的代码自己看不懂也很正常）。
那我们觉得不行啊，那要不就对每个文件打一个标记，当有人正在修改的时候就启用标记，当这个人的修改完成后就释放这个标记。这好像是解决了不能多个人修改同一个源文件的问题，但它是串行的，不够异步，这就有可能造成“线程饥饿”的问题，如果多个人都对同一个源文件有修改的需求，那可不就都在等待这个正在占用的人了吗？效率还是不够高。
那我们还可以专门设定一个人，由他来接受每个人对于同一个源文件的所有修改，并且由他结合所有的修改来设定最终的源文件，如果修改有冲突了，他还可以去找那些修改有冲突的程序员，然后商定保留哪部分修改。效果显而易见的好，成本显而易见的高——要多一个人的工资呢。那我们是不是就可以退而求其次，看看有没有软件能够替我们完成这个合并修改的工作呢？有的兄弟有的，在此先按下不表。
当然现代很多工具都已经能做到实时的同步修改了，但这一类服务的价格可能比上一种方案的那个人的工资都高。
我们以上也只是分析了合作完成这件事的需要，现实中还会涉及到计算每个人对项目的贡献量，错误代码的追责等，因此改动的简介、作者和时间信息也需要被记录下来。
#### 代码风格统一
为了我们代码的一致性、可读性和可维护性，我们需要遵循一定的编码规范，比如统一的缩进风格、变量命名规则、函数的长度限制、注释的格式等。但人是自由的，每个人的编码风格可能大相径庭，因此我们需要有一个工具来帮助我们自动化地对代码进行格式化，又或者检测代码是否符合规范。
（这个问题我不会单独介绍工具的使用方法，而是会介绍一些规范的意思）
### 版本控制
我们写代码，尤其是完成复杂的项目时，往往都不是一蹴而就的，而是经历了多次的开发迭代，可能是分模块开发，可能是按功能开发，或者为不同的客户服务而需要不同的功能集合，又或是某个功能使用不同特性的实现，又或者是在开发过程中又有了新想法，或者是项目的需求发生了变化，或者是某些改动需要舍弃并回到之前的版本，亦或是只是需要记录开发过程。
我们可以将特定的功能集合和特性集合视为一个版本，我们需要一个版本控制系统来记录每个版本的变更，以便于后续的查阅和回滚，又或者是不同版本之间功能集合和特性集合的合并和对比。
有趣的是，如果我们将合作编码中每一次的修改都视为一个版本，那么我们就可以借助版本管理工具来完成我们以上两个需求。
### 项目管理和任务分发
对于项目的管理者来说，他需要一个途径获取项目目前的进展、状态和问题，以及任务的向下分发，以保证项目对于管理者的实时性，对于开源项目来说可能任务分发没有那么重要，但对于固定团队的项目来说，任务分发就显得尤为重要，这关系到每个开发者的能力能否得到有效的发挥，以及项目的进展如何被管理者看到。
并且对于企业来说，也需要知道项目中每个成员对于该项目的贡献程度，以及记录任务的完成情况，以便于管理者对项目的整体进展和各个成员的工作情况进行评估。
对于开发者来说，我想你们在之前的工作中应该也感觉出来了，很多时候会不知道自己应该做什么，或者有了新的成果却无从汇报。
结合以上的分析，我们需要有那么一个工具，帮助我们完成项目管理和任务分发，并且能够记录每个人的贡献量，错误追责等，以便于管理者对项目的整体进展和各个成员的工作情况进行评估。
那对于我们这个项目来说，我们没有那么多复杂的需求，但是任务分发和进展的记录还是很重要的。
（那接下来也会有我来对你们进行任务的分发，你们也要及时响应才行。）
### 文档协作
写文档是开发中不得不品鉴的一环，对于一个产品来说，你需要事无巨细的把功能描述出来，对于一个代码库来说，你需要详细的记录每个模块的功能和实现，以及类型和接口的定义。并且如果有多个开发者参与开发，且可能会修改或使用同一部分代码，那么对这些代码的说明文档也是必须的。
而对于最后需要交付的文档，很多时候更像是在一起编辑同一个源文件，且大部分情况下，这个修改是同时进行的，因此能够实时看到其他人的修改的文档协作就显得尤为重要。
### 即时通讯
即时通讯我就不单独说了，这里只是列出来，提醒你们有问题或者有进度一定要及时和我说。

# 工具

那我接下来就会关于版本控制、代码检查、项目管理、文档协作来介绍一些我们接下来完成项目的过程中需要使用的工具。

## 版本控制
版本控制会有不同的方案，整体上可以分为集中式和分布式两种，集中式版本控制就是有一个中心服务器存储所有版本，由中心服务器完成所有版本控制的工作，而分布式版本控制则是每个开发者都有一份完整的版本库，版本控制工作都由各自的客户端完成，只是会在中心服务器上进行同步。
在此我只介绍Git，我们也将使用Git来完成我们的项目的版本控制。
### Git
Git是一个开源的分布式版本控制系统，由Linux之父Linus Torvalds开发，是目前最流行的版本控制系统。
Git本体提供了很多强大的命令行工具，而通过上次我讲的脚本的编写，我们也可以实现一些更加高级的功能，我在此只讲解Git的基本工作方式和使用方法，以及我会带你们过一遍Git的基本命令。
#### 基本工作方式
Git做的所有事情就是简单概括就是维护一个仓库（Repository）——一个保存项目历史记录的地方，也就是.git目录。
由Git进行管理的目录分为三个部分：工作区、暂存区和本地仓库。
- 工作区：就是你在电脑里能看到的目录，通过命令将文件的修改情况添加到暂存区。
- 暂存区：英文叫stage，临时保存修改文件用的，通过命令将暂存区的记录提交到本地仓库。
- 本地仓库：就是.git目录，这里边保存着所有的版本信息，包括提交记录、版本快照等。
文件在工作区的状态有三种：已修改（modified）、已暂存（staged）和未跟踪（untracked）。
- 已修改：表示文件已在工作区被修改，但还没有被暂存。
- 已暂存：表示文件已在暂存区，等待提交到本地仓库。
- 未跟踪：表示文件在工作区中，但并没有被纳入版本控制。
Git会检测被追踪文件的状态，并和本地仓库中的文件进行比较，如果文件不一样，Git会将文件状态标记为已修改。
而对于我们使用者来说，Git如何组织这些文件，以及如何管理这些文件，并不重要，重要的是Git暴露给我们的拓扑结构，以及Git提供的命令行工具。
分支（Branch）是 Git 的一个核心特性，它允许开发者在同一仓库中并行开发不同的功能或修复，而互不干扰。
我光靠语言描述可能比较抽象，你们看一下这个图就懂了：



我们使用git记录一个版本的流程大概是这样的：
1. 对目录启用Git进行版本管理。
    在该步骤中，使用的是
    ```bash
    git init
    ```
    这个命令，将当前目录变成一个Git仓库。
2. 在工作区中修改文件。
3. 将修改的文件添加到暂存区。
    在该步骤中，使用的是
    ```bash
    git add <文件路径>
    ```
    这个命令，将文件添加到暂存区。
4. 将暂存区的记录提交到本地仓库。
    在该步骤中，使用的是
    
    ```bash
    git commit -m "提交说明"
    
    ```
    这个命令，将暂存区的记录提交到本地仓库，并附上提交说明。
5. 将本地仓库的记录推送到远程仓库。
    在该步骤中，使用的是
    
    ```bash
    git push <远程仓库名> <分支名>
    ```
    这个命令，将本地仓库的记录推送到远程仓库，并指定推送的分支。
6. 从远程仓库拉取最新版本。
    在该步骤中，使用的是
        
    ```bash
    git pull <远程仓库名> <分支名>
    
    ```
    这个命令，从远程仓库拉取最新版本，并合并到本地仓库的指定分支。
#### 全部命令及参数介绍


