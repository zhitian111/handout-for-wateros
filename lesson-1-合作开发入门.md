# 引言
一个人的力量是有限的，而以生产（而非学习）为目的任务是有截止日期的，哪怕再强大的程序员也不可能只靠自己就能在指定期限内完成项目。因此我们必须依靠团队合作，结合多个人的劳动来完成任务。
当人与人之间的合作是异步地对同一客体进行劳动时，在我看来，有两个核心的要点——“共识”和“隔离”。
## 共识
你也可以将它称之为规则、协议等，共识就是劳动中的所有主体为达成同一最终目的而创造的，所有人都知晓信息，所有人都遵守的规范。在合作开发中，它可以体现为编码规范，项目结构等。我们按照共识行事是为了所有人的劳动都能够对项目起到推进作用，且保证产出的劳动成果的一致性。那对于写代码来说，就是你不能随意地按照自己的风格去编写代码，而应该遵循团队所制定的编码规范。比如，代码的缩进风格、变量命名规则、函数的长度限制、注释的格式等。这些看似琐碎的细节，实际上是团队协作中不可或缺的部分。如果每个人都按照自己的方式去写代码，那么最终的代码库就会变得混乱不堪，难以维护和理解。当新的成员加入团队或者需要对代码进行后续的修改和扩展时，就会花费大量的时间去适应不同的代码风格，甚至可能会引入新的错误。
## 隔离
与共识不同，隔离指的是劳动中所有主体劳动成果之间的独立性和可见性。我们应当尽可能保证自己的劳动不会影响其他人已有的劳动成果，且对于每一个劳动者，我们不去关注其劳动过程和劳动成果的具体实现细节，即我们预设每个人做出的成果都是与其描述的是一致的。那对于我们合作开发来说，它可以体现在模块化的开发，以及接口的暴露上。这样，不同的开发者可以独立地开发不同的模块，而不用担心会影响到其他模块的正常运行。当一个模块出现问题时，也可以很容易地定位和修复，而不会导致整个项目的崩溃。而接口的设计也可以让我们可以只考虑如何使用功能，而不用在意如何实现功能。抽象层次就是人类在计算机领域最伟大的发明。

## 需求
我们知道，市面上的产品大多都是面向需求开发的，了解了上文后，我们还知道，其实使用现有的面向合作开发的产品实际上也是在遵循这项产品的共识和隔离属性，使用它们的目的是提高我们合作劳动的效率，如果不能实际地提高效率，那学习它们就没有意义。

因此，我们就需要对我们合作开发的需求进行分析，以便确认我们为什么需要它们，以及我们应该挑选哪些产品。


### 合作编码
那首先，我们知道，编译程序或者是解释程序，是需要所有源文件或脚本文件都存放在特定目录下，或者通过参数传入编译器、解释器或者链接器的。这些工作绝大部分现代IDE都为我们完成了，对于大部分项目来说，我们可以只考虑源文件的编写和项目目录结构的组织。
但这里就会遇到问题，如果两个或多个人同时编辑了某个源文件怎么办？那最简单的解决方法就是我们规定每个源文件都只能由同一个人负责，但这无疑是即傻瓜式又不负责任的做法，显而易见的低效，但也并非没有优点：只要项目成员不中途跳车或不负责任，那项目的维护难度就非常低（当然只是相对来说，自己的代码自己看不懂也很正常）。
那我们觉得不行啊，那要不就对每个文件打一个标记，当有人正在修改的时候就启用标记，当这个人的修改完成后就释放这个标记。这好像是解决了不能多个人修改同一个源文件的问题，但它是串行的，不够异步，这就有可能造成“线程饥饿”的问题，如果多个人都对同一个源文件有修改的需求，那可不就都在等待这个正在占用的人了吗？效率还是不够高。
那我们还可以专门设定一个人，由他来接受每个人对于同一个源文件的所有修改，并且由他结合所有的修改来设定最终的源文件，如果修改有冲突了，他还可以去找那些修改有冲突的程序员，然后商定保留哪部分修改。效果显而易见的好，成本显而易见的高——要多一个人的工资呢。那我们是不是就可以退而求其次，看看有没有软件能够替我们完成这个合并修改的工作呢？有的兄弟有的，在此先按下不表。
当然现代很多工具都已经能做到实时的同步修改了，但这一类服务的价格可能比上一种方案的那个人的工资都高。
我们以上也只是分析了合作完成这件事的需要，现实中还会涉及到计算每个人对项目的贡献量，错误代码的追责等。
### 版本控制

### 项目管理和任务分发

### 文档协作

### 即时通讯